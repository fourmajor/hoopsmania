name: Codeowner + Docdrip Review Gate

on:
  pull_request_target:
    types: [opened, synchronize, reopened, ready_for_review]
  pull_request_review:
    types: [submitted, edited, dismissed]

permissions:
  contents: read
  pull-requests: read

jobs:
  require-reviews:
    if: github.event.pull_request.draft == false
    runs-on: ubuntu-latest
    steps:
      - name: Enforce codeowner and docdrip approvals
        uses: actions/github-script@v8
        with:
          script: |
            const pr = context.payload.pull_request;
            if (!pr) {
              core.info('No pull request payload; skipping.');
              return;
            }

            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const number = pr.number;

            // Keep matching intentionally simple: directory-prefix ownership.
            const ownership = [
              { prefix: 'web/', owners: ['fourmajor'] },
              { prefix: 'backend/', owners: ['fourmajor'] },
              { prefix: 'automation/', owners: ['fourmajor'] },
              { prefix: 'docs/', owners: ['fourmajor'] },
              { prefix: '.github/', owners: ['fourmajor'] },
            ];

            const isDocPath = (filename) =>
              filename.startsWith('docs/') ||
              filename.endsWith('.md') ||
              filename.endsWith('.mdx') ||
              filename.endsWith('.rst') ||
              filename.endsWith('.txt');

            const files = await github.paginate(
              github.rest.pulls.listFiles,
              { owner, repo, pull_number: number, per_page: 100 }
            );

            const changed = files.map(f => f.filename);
            core.info(`Changed files: ${changed.join(', ') || '(none)'}`);

            const nonDocChanged = changed.filter((f) => !isDocPath(f));
            const docsChanged = changed.filter((f) => isDocPath(f));
            const docOnlyPr = changed.length > 0 && nonDocChanged.length === 0;

            core.info(`Doc-only PR: ${docOnlyPr}`);
            core.info(`Non-doc files: ${nonDocChanged.join(', ') || '(none)'}`);
            core.info(`Doc files: ${docsChanged.join(', ') || '(none)'}`);

            const requiredOwners = new Set();
            for (const file of changed) {
              for (const rule of ownership) {
                if (file.startsWith(rule.prefix)) {
                  for (const o of rule.owners) requiredOwners.add(o.toLowerCase());
                }
              }
            }

            const reviews = await github.paginate(
              github.rest.pulls.listReviews,
              { owner, repo, pull_number: number, per_page: 100 }
            );

            // Latest state per reviewer wins for codeowner gate.
            const latest = new Map();
            for (const r of reviews) {
              const login = r.user?.login?.toLowerCase();
              if (!login) continue;
              latest.set(login, r.state);
            }

            const approvedBy = new Set(
              [...latest.entries()]
                .filter(([, state]) => state === 'APPROVED')
                .map(([login]) => login)
            );

            const authorLogin = pr.user?.login?.toLowerCase();
            const authorIsRequiredOwner = authorLogin && requiredOwners.has(authorLogin);
            const hasCodeownerApproval =
              requiredOwners.size === 0 ||
              authorIsRequiredOwner ||
              [...requiredOwners].some(o => approvedBy.has(o));

            core.info(`Required owners: ${[...requiredOwners].join(', ') || '(none)'}`);
            core.info(`Approved by: ${[...approvedBy].join(', ') || '(none)'}`);
            core.info(`PR author: ${authorLogin || '(unknown)'}`);
            if (authorIsRequiredOwner) {
              core.info('PR author is a required codeowner; treating as approved.');
            }

            if (!hasCodeownerApproval) {
              core.setFailed(
                `Missing codeowner approval. Required owner(s): ${[...requiredOwners].join(', ')}`
              );
              return;
            }

            // Docdrip policy gate: required only for non-doc PRs.
            if (docOnlyPr) {
              core.info('Doc-only PR detected; docdrip review gate not required.');
              return;
            }

            // Require an APPROVED review comment that explicitly attributes docdrip
            // and states documentation impact.
            const docdripApprovedReviews = reviews.filter((r) => {
              if (r.state !== 'APPROVED') return false;
              const body = (r.body || '').toLowerCase();
              return body.includes('ai employee: docdrip');
            });

            if (docdripApprovedReviews.length === 0) {
              core.setFailed(
                'Missing docdrip approval for non-doc PR. Add an APPROVED review containing `AI Employee: docdrip` and doc impact status.'
              );
              return;
            }

            const latestDocdrip = docdripApprovedReviews[docdripApprovedReviews.length - 1];
            const docdripBody = (latestDocdrip.body || '').toLowerCase();
            const saysUpdated = docdripBody.includes('doc impact: updated');
            const saysNone = docdripBody.includes('doc impact: none');

            if (!saysUpdated && !saysNone) {
              core.setFailed(
                'Docdrip approval must include `Doc Impact: updated` or `Doc Impact: none`.'
              );
              return;
            }

            if (saysUpdated && docsChanged.length === 0) {
              core.setFailed(
                'Docdrip marked `Doc Impact: updated`, but no documentation files were changed in this PR.'
              );
              return;
            }

            core.info('Docdrip review gate satisfied for non-doc PR.');
